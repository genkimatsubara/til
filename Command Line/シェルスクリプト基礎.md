# シェルスクリプトメリット
- 一度シェルスクリプトを作れば、後で同じ処理が必要になった時にそのシェルスクリプトを再利用できる
- 自分だけではなく、他の人にもシェルスクリプトを配布して使ってもらうことができる
- コマンドを打ち間違えることなく作業できる

# 基礎知識
### ファイル名
ファイル名の拡張子を`sh`にするのは、シェルスクリプトの習慣。ファイル名を見ただけでシェルスクリプトだとわかるようにするため
### 実行権限
シェルスクリプトは実行されるファイルなので、`+x`として実行権限をつけておく必要がある。
```
chmod +x ファイル名
```
# シェルスクリプトの実行形式
ファイルの先頭に`#!`で始まる行を追加する必要がある。これはシバンと呼ばれ、特別な意味を持つ<br>
シェルから実行命令を受けたLinuxカーネルは、対象のファイルの先頭を確認し、`#!`があった場合には、その後ろに描かれたコマンドを実行するという動作をする<br>
つまり、`#!/bin/bash`という行は、「このシェルスクリプトは/bin/bashで動かします」という宣言をしている。

# シェルスクリプト基本
### シェルスクリプトの行
複数のコマンドを`;`で区切ることで、1行にまとめて書くことができる。<br>
コマンドラインが長くなってします場合にはあ、行末に`\`を置くことで途中で改行ができる。
### 変数名に利用できる文字
変数名に利用できる文字は、アルファベットと数値とアンダースコアだけ。また、数値は先頭の１文字目に使うことはできない。<br>
変数名の部分を`{}`で囲むと変数名の区切りを明示することができる。
### クォート中の変数展開
- シングルクォート<br>
シングルクォートの中では、`$`も特殊な意味を失うため変数は展開されず、`$`はそのまま`$`記号となる
- ダブルクォート<br>
ダブルクォートの中では、`$`による変数展開や、コマンドの置換は有効
### コマンドの置換
コマンドの結果を文字列として取得すること<br>
コマンドの置換は`$()`という形式で、カッコ内に実行したいコマンドを記述する。
```
now=$(date '+%Y-%m-%d')
echo now
```
コマンド置換はバッククォートで囲む記法もあるが、わかりにくいため`$()`の方が良い


# 制御構造
### if文
```
if<コマンド1>;then
  <コマンド1>の結果が真である場合の処理
elif<コマンド2>;then
  <コマンド2>の結果が真である場合の処理
elif<コマンド3>;then
  <コマンド3>の結果が真である場合の処理
else
  上記の結果がすべて偽である場合の処理
fi
```
```
if [ "$1" = "bin" ];then
```
ファイルが存在するかどうかの判定もできる<br>
- 種類を問わず存在しているかどうかを調べるには`-e`
- ファイルが存在しているかは`-f`
- ディレクトリが存在しているかどうかは`-d`で調べることができる。

カッコの前後のスペースを除くとエラーになってしまうので気をつける！！！
### for文
```
for 変数名 in リスト
do
  繰り返す処理
done
```
`seq`コマンドをfor文に利用すると、連番に対して順に処理が行える
```
for i in $(seq 1 5)
do
  echo i
done
```
### case文
`case`文は、指定された文字列がパターンマッチするかどうかを判断し、マッチしたパターンに対応する処理を行うための制御構造
```
case <文字列> in
  <パターン１>)
    処理
     ;;
  <パターン2>)
    処理
     ;;
  *)
    それ以外
     ;;
esac
```
### while文
`while`は、指定した条件が真である限り繰り返し処理を行う制御構文
```
while <コマンド>
do
  繰り返し処理
done
```

### ループ命令
- ループをスキップするための`continue`
- ループを抜けるための`break`

# ユーザから入力を受け付ける
`read` <変数><br>
変数に入力された値を入れてくれる<br>
### 入力前にテキストを表示したい場合
```
read -p "Name: " name
```
のように書きと入力前にテキストを表示できる！

# 配列
```
colors=(red blue pink)
echo ${colors[0]} # red
echo ${colors[1]} # blue
echo ${colors[2]} # pink
echo ${colors[@]} # red blue pink
echo ${#colors[@]} # 3
```

### 算術式展開
bashでは`$(( ))`と2重のカッコで括ることにより、中に書いた文字列を計算式として扱うことができる

### 文字列に関する評価演算子
| 演算子 | 内容 |
| :--- | :--- |
| str1 == str2 | str1とstr2が等しい |
| str1 != str2 | str1とstr2が等しくない |
| -n str1 | str1が空文字列ではない |
| -z str1 | str1が空文字列である |

### 整数に関する評価演算子
| 演算子 | 内容 |
| :--- | :--- |
| int1 -eq int2 | int1とint2が等しい |
| int1 -ne int2 | int1とint2が等しくない |
| int1 -lt int2 | int1がint2より小さい |
| int1 -le int2 | int1がint2以下 |
| int1 -gt int2 | int1がint2より大きい |
| int1 -ge int2 | int1がint2以上 |

これらの演算子は整数しか扱えないので、小数の比較はできない

### 結合演算子
| 演算子 | 内容 |
| :--- | :--- |
| 条件式1 -a 条件式2 | 条件式1と条件式2の両方が真の場合に真（AND） |
| 条件式1 -o 条件式2 | 条件式1と条件式2の少なくとも一つが真の場合に真（OR） |
| ！条件式 | 条件式の真偽を逆にする（NOT） |
| （） | 条件式をグループ化する |

### &&と||
`&&`は2つのコマンドを連結して`コマンド１ && コマンド`という形式で利用する。<br>
コマンド１が正常に終了した時にだけコマンド２を実行するという、使い方ができる。<br>
`||`は2つのコマンドを連結して、`コマンド１ || コマンド２`という形式で利用する。<br>
コマンド１が正常終了しなかった時だけコマンド２を実行するという、使い方ができる。

ファdファdファdファd
